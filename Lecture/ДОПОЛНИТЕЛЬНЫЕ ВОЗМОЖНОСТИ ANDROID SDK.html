<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--metatextblock-->
  <title>ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK</title>
  <meta name="description" content="Доклад">

  <meta property="og:title" content="ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK">
  <meta property="og:description" content="Доклад">
  <meta property="og:type" content="website">

  <meta name="robots" content="nofollow">
  <link rel="shortcut icon" href="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/icon.png" type="image/x-icon">

  <link rel="stylesheet" href="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/grid-3.0.min.css" type="text/css" media="all">
  <link rel="stylesheet" href="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/blocks-2.12.css" type="text/css" media="all">
  <link rel="stylesheet" href="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/animation-1.0.min.css" type="text/css" media="all">
  <script type="text/javascript" async="" id="statscript" src="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/simplestat-0.1.min.js.Без названия"></script>
  <script src="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/jquery-1.10.2.min.js.Без названия"></script>
  <script src="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/scripts-2.8.min.js.Без названия"></script>
  <script src="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/blocks-2.7.js.Без названия"></script>
  <script src="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/lazyload-1.3.min.js.Без названия" charset="utf-8"></script>
  <script src="./ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK_files/animation-1.0.min.js.Без названия" charset="utf-8"></script>
  <script type="text/javascript">
    window.dataLayer = window.dataLayer || [];
  </script>
  <script type="text/javascript">
    if ((/bot|google|yandex|baidu|bing|msn|duckduckbot|teoma|slurp|crawler|spider|robot|crawling|facebook/i.test(navigator.userAgent)) === false && typeof(sessionStorage) != 'undefined' && sessionStorage.getItem('visited') !== 'y') {
      var style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = '@media screen and (min-width: 980px) {.t-records {opacity: 0;}.t-records_animated {-webkit-transition: opacity ease-in-out .2s;-moz-transition: opacity ease-in-out .2s;-o-transition: opacity ease-in-out .2s;transition: opacity ease-in-out .2s;}.t-records.t-records_visible {opacity: 1;}}';
      document.getElementsByTagName('head')[0].appendChild(style);
      $(document).ready(function() {
        $('.t-records').addClass('t-records_animated');
        setTimeout(function() {
          $('.t-records').addClass('t-records_visible');
          sessionStorage.setItem('visited', 'y');
        }, 400);
      });
    }
  </script>
  <style type="text/css">
    @media screen and (min-width: 980px) {
      .t-records {
        opacity: 0;
      }
      .t-records_animated {
        -webkit-transition: opacity ease-in-out .2s;
        -moz-transition: opacity ease-in-out .2s;
        -o-transition: opacity ease-in-out .2s;
        transition: opacity ease-in-out .2s;
      }
      .t-records.t-records_visible {
        opacity: 1;
      }
    }
  </style>
</head>

<body class="t-body" style="margin: 0px;">
  <!--allrecords-->
  <div id="allrecords" class="t-records t-records_animated t-records_visible" data-hook="blocks-collection-content-node" data-project-id="3782219" data-page-id="17833791" data-formskey="d93eec1f63b6591746edf29e93c1f0d0" dataa-lazy="yes">
    <div id="rec288581839" class="r t-rec t-rec_pt_90 t-rec_pb_90" style="padding-top:90px;padding-bottom:90px;background-color:#1f5bff; " data-record-type="468" data-bg-color="#1f5bff" data-animationappear="off">
      <!-- t468 -->
      <div class="t468">
        <div class="t-container t-align_center">
          <div class="t-col t-col_10 t-prefix_1">
            <div class="t468__title t-title t-title_lg t-margin_auto" field="title" style=""><strong>ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ ANDROID SDK</strong></div>
            <div class="t468__descr t-descr t-descr_xl t-margin_auto" field="descr" style="">Источники медиа-данных. Использование инструментов Android SDK для записи и воспроизведения аудио и видео, работы с камерой и изображениями.
              <br>Поддержка телефонии, отправки и получения SMS.
              <br>Реализация взаимодействия приложения с геолокационными и картографическими сервисами.
              <br>
              <br>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288572075" class="r t-rec t-rec_pt_30 t-rec_pb_0 r_showed r_anim" style="padding-top:30px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style=""><strong>&nbsp; &nbsp;Android SDK</strong> — универсальное средство разработки мобильных приложений для операционной системы Android. Отличительной чертой от обычных редакторов для написания кодов является наличие широких функциональных возможностей, позволяющих запускать тестирование и отладку исходных кодов, оценивать работу приложения в режиме совместимости с различными версиями ОС Android и наблюдать результат в реальном времени (опционально). Поддерживает большое количество мобильных устройств, среди которых выделяют: мобильные телефоны, планшетные компьютеры, умные очки (в том числе Google Glass), современные автомобили с бортовыми компьютерами на ОС Андроид, телевизоры с расширенным функционалом, особые виды наручных часов и многие другие мобильные гаджеты, габаритные технические приспособления.
              <br>&nbsp;&nbsp;Android SDK был выпущен в октябре 2009 года. Среда разработки является кросс-платформенной, значительная часть комплекта написана на языке программирования Java.</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288573712" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_showed r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">
              <p style="text-align: center;"><strong style="font-size: 24px;">Использование геолокационных сервисов</strong><strong> </strong></p>&nbsp;&nbsp;Геолокационные сервисы (LBS) — обобщающий термин, описывающий различные технологии, которые применяются для поиска текущего местоположения устройства.
              <br>&nbsp;&nbsp;Обозначим две главные составляющие LBS:
              <br>&nbsp;&nbsp;• LocationManager — предоставляет интерфейс к геолокационным сервисам.
              <br>&nbsp;&nbsp;• LocationProvider — предоставляет разные Источники данных, основанные на различных технологиях определения местоположения.
              <br>&nbsp;&nbsp;С помощью LocationManager можно:
              <br>&nbsp;&nbsp;• получать текущее местоположение;
              <br>&nbsp;&nbsp;• отслеживать передвижение;
              <br>&nbsp;&nbsp;• настраивать оповещения о близости нахождения таким образом, чтобы они срабатывали при входе в указанную область и при выходе из нее;
              <br>&nbsp;&nbsp;• находить доступные Источники данных для определения местоположения.
              <br>&nbsp;&nbsp;В зависимости от устройства Android может применять несколько разных технологий для определения текущего местоположения. Каждая технология, или LocationProvider, предоставляет разные возможности (касается разницы в уровне энергопотребления, стоимости услуг и возможности определять высоту над уровнем моря, скорость или информацию о курсе).
              <br>&nbsp;&nbsp;Чтобы получить экземпляр конкретного Источника данных, вызовите метод getProvider, передав ему нужное название:</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288576795" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="248">
      <!-- T220 -->
      <div class="t220">
        <div class="t-container ">
          <div class="t-col t-col_8 t-prefix_2">
            <div class="t220__textwrapper" style="background-color:#f5f6ff;">
              <div style="">
                <div field="text" class="t220__text t-text t-text_md " style="">String providerName = LocationManager.GPS_PROVIDER;
                  <br>LocationProvider gpsProvider;
                  <br>gpsProvider = locationManager.getProvider(providerName);</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288576701" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;Как правило, это нужно исключительно для определения возможностей конкретного источника
              <br>&nbsp;&nbsp;Цель геолокационных сервисов — определение физического местоположения вашего устройства. За доступ к геолокационным сервисам отвечает системная служба LocationManager. Чтобы начать работу с ней, получите экземпляр типа LOCATION_SERVICE с помощью метода getSystemService, как показано в следующем фрагменте кода:</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288575854" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="248">
      <!-- T220 -->
      <div class="t220">
        <div class="t-container ">
          <div class="t-col t-col_8 t-prefix_2">
            <div class="t220__textwrapper" style="background-color:#f5f6ff;">
              <div style="">
                <div field="text" class="t220__text t-text t-text_md " style="">String serviceString = Context.LOCATION_SERVICE;
                  <br>LocationManager locationManager;
                  <br>locationManager = (LocationManager)getSystemService(serviceString); </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288576904" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;Прежде чем использовать LocationManager, необходимо добавить один или несколько тегов, описывающих пользовательские полномочия (usespermission), к манифесту приложения, чтобы получить доступ к аппаратному обеспечению, отвечающему за геолокационные сервисы.
              <br>&nbsp;&nbsp;Вы можете получить последнее местоположение, зафиксированное LocationProvider, используя метод getLastKnownLocation, но предварительно передав ему в качестве параметра имя Источника данных. В следующем примере получено последнее зафиксированное местоположение, взятое у источника GPS:</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288577009" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="248">
      <!-- T220 -->
      <div class="t220">
        <div class="t-container ">
          <div class="t-col t-col_8 t-prefix_2">
            <div class="t220__textwrapper" style="background-color:#f5f6ff;">
              <div style="">
                <div field="text" class="t220__text t-text t-text_md " style="">String provider = LocationManager.GPS_PROVIDER;
                  <br>Location location = locationManager.getLastKnownLocation(provider);</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288577304" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;Возвращенный объект Location содержит всю позиционную информацию, которую поддерживает источник. Он может включать широту, долготу, азимут, высоту над уровнем моря, скорость и время, когда последний раз фиксировалось местоположение. Все эти свойства доступны через геттеры объекта Location.
              <br>&nbsp;&nbsp;Несколько классов, которые используются для поддержки картографии в Android.
              <br>&nbsp;&nbsp;• MapView.Элемент управления картами.
              <br>&nbsp;&nbsp;• MapActivity. Базовый класс, при наследовании которого создается новая Активность, содержащая MapView. Класс MapActivity управляет жизненным циклом приложения и фоновыми задачами, необходимыми для отображения карт. Поэтому элементы MapView используются только внутри Активности, наследованной от MapActivity.
              <br>&nbsp;&nbsp;• Overlay. Этот класс требуется для добавления аннотаций к вашей карте. Используя Наложения, можно рисовать произвольное количество слоев на элементе Canvas, и они будут отображены поверх MapView.
              <br>&nbsp;&nbsp;• MapController. Используется для управления картой, в том числе указания местоположения и уровня масштаба.
              <br>&nbsp;&nbsp;• MyLocationOverlay. Специальное Наложение, которое может быть применено для показа текущего местоположения и ориентации устройства.
              <br>&nbsp;&nbsp;• ItemizedOverlays и OverlayItems. Работают совместно, позволяют создавать слой меток, которые будут отображаться с помощью объектов Drawable и соответствующего текста.
              <br>&nbsp;&nbsp;Чтобы использовать MapView в вашем приложении, сперва нужно получить ключ для API на сайте для разработчиков под Android http:// code.google.com/android/maps-api-signup.html.
              <br>&nbsp;&nbsp;Без ключа для API MapView не загрузит необходимые для отображения карты фрагменты.
              <br>&nbsp;&nbsp;Если хотите использовать карты в своем приложении, то должны наследовать класс MapActivity. Разметка нового класса обязана включать MapView для отображения карт Google Maps. Картографическая библиотека в Android — нестандартный пакет. Как дополнительный API, она должна быть явно внесена в манифест приложения перед использованием. Добавьте библиотеку в ваш манифест с помощью тега uses-library, включив его внутрь узла application, как показано в следующем фрагменте кода XML:</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288577528" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="248">
      <!-- T220 -->
      <div class="t220">
        <div class="t-container ">
          <div class="t-col t-col_8 t-prefix_2">
            <div class="t220__textwrapper" style="background-color:#f5f6ff;">
              <div style="">
                <div field="text" class="t220__text t-text t-text_md " style="">&lt;uses-library android:name="com.google.android.maps"/&gt;</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288577725" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;MapView загружает фрагменты карты при необходимости. В связи с этим он косвенно требует полномочий для использования Интернета. Поэтому нужно добавить тег , содержащий полномочие INTERNET, в манифест вашего приложения, как показано ниже:</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288577850" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="248">
      <!-- T220 -->
      <div class="t220">
        <div class="t-container ">
          <div class="t-col t-col_8 t-prefix_2">
            <div class="t220__textwrapper" style="background-color:#f5f6ff;">
              <div style="">
                <div field="text" class="t220__text t-text t-text_md " style="">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288577958" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;Добавив библиотеку и настроив полномочия, вы готовы к созданию новой Активности, использующей возможности картографии. Элемент управления MapView может функционировать только в сочетании с Активностью — потомком MapActivity</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288578073" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">
              <p style="text-align: center;"><strong style="font-size: 24px;">Телефония</strong></p>&nbsp;&nbsp;API в Android, предназначенные для поддержки телефонии, открывают доступ приложений к низкоуровневому аппаратному стеку телефона. Благодаря этому разработчики могут инициировать набор номера или интегрировать обработку звонков и отслеживание состояния телефона в свои проекты.
              <br>&nbsp;&nbsp;Для инициирования телефонных звонков используются Намерения, запускающие для этого стандартное приложение. Вызывая Активность для дозвона с помощью Намерения, необходимо указать номер, на который пойдет звонок, используя схему tel: в качестве компонента с данными.
              <br>&nbsp;&nbsp;Вместо немедленного дозвона примените действие Intent.ACTION_ DIAL, чтобы отобразить экран для набора номера. Оно загружает Активность для дозвона и передает ей указанный номер, позволяя стандартному приложению самому управлять инициализацией вызова (системное телефонное приложение предлагает решать пользователю, делать вызов или нет). Этот подход не требует никаких полномочий и считается стандартным путем осуществления звонков из сторонних приложений.
              <br>&nbsp;&nbsp;Далее демонстрируется базовая методика для набора телефонного номера.</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288578692" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="248">
      <!-- T220 -->
      <div class="t220">
        <div class="t-container ">
          <div class="t-col t-col_8 t-prefix_2">
            <div class="t220__textwrapper" style="background-color:#f5f6ff;">
              <div style="">
                <div field="text" class="t220__text t-text t-text_md " style="">Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:1234567"));
                  <br>startActivity(intent);</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288578746" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;Доступ к телефонным API контролируется объектом TelephonyManager, который можно получить с помощью метода getSystemService, как показано далее.</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288578872" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="248">
      <!-- T220 -->
      <div class="t220">
        <div class="t-container ">
          <div class="t-col t-col_8 t-prefix_2">
            <div class="t220__textwrapper" style="background-color:#f5f6ff;">
              <div style="">
                <div field="text" class="t220__text t-text t-text_md " style="">TelephonyManager String srvcName = Context.TELEPHONY_SERVICE;
                  <br>TelephonyManager telephonyManager = (TelephonyManager) getSystemService(srvcName); </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288578985" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;TelephonyManager предоставляет прямой доступ ко многим телефонным свойствам, в том числе к информации об устройстве, сети, SIM-карте и ходе передачи данных.</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288579009" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">
              <p style="text-align: center;"><strong style="font-size: 24px;">SMS</strong></p>&nbsp;&nbsp;Технология SMS разработана для обмена небольшой по объему текстовой информацией между мобильными телефонами. Она поддерживает отправку как текстовых (пригодных для чтения человеком), так и бинарных (созданных для обработки приложениями) сообщений.
              <br>&nbsp;&nbsp;Android предоставляет разработчикам приложений полную поддержку SMS. С помощью объекта SmsManager вы можете заменить стандартную программу для работы с SMS, отсылая и принимая текстовые сообщения или используя SMS в виде протокола для доставки данных.
              <br>&nbsp;&nbsp;Иногда проще доверить другому приложению всю работу по передаче SMS и MMS вместо того, чтобы самостоятельно реализовывать полноценный клиент для этих задач внутри своей программы. Чтобы это сделать, вызовите метод startActivity с помощью Намерения, которому присвоено действие Intent.ACTION_SENDTO. В качестве данных для Намерения укажите номер адресата, используя схему sms:. С помощью дополнительного параметра sms_body задайте текст сообщения.</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288579197" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="248">
      <!-- T220 -->
      <div class="t220">
        <div class="t-container ">
          <div class="t-col t-col_8 t-prefix_2">
            <div class="t220__textwrapper" style="background-color:#f5f6ff;">
              <div style="">
                <div field="text" class="t220__text t-text t-text_md " style="">Intent smsIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse("sms:55512345"));
                  <br>smsIntent.putExtra("sms_body", "Press send to send me"); startActivity(smsIntent);</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288579368" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;Чтобы отслеживать и подтверждать успешность доставки своих исходящих SMS, реализуйте и зарегистрируйте Приемники широковещательных намерений. Они должны быть настроены на действия, указанные вами при создании Ожидающих намерений, которые вы передали в метод sendTextMessage.
              <br>&nbsp;&nbsp;Первое Намерение, sentIntent, срабатывает, когда сообщение успешно отправляется (либо когда возникают какие-то проблемы). Код результата для Приемника, который получает данное Намерение, будет иметь одно из следующих значений:
              <br>&nbsp;&nbsp;• Activity.RESULT_OK — успешная отправка;
              <br>&nbsp;&nbsp;• SmsManager.RESULT_ERROR_GENERIC_FAILURE — при отправке возникли неизвестные проблемы;
              <br>&nbsp;&nbsp;• SmsManager.RESULT_ERROR_RADIO_OFF — телефонный модуль выключен;
              <br>&nbsp;&nbsp;• SmsManager.RESULT_ERROR_NULL_PDU — возникла проблема, связанная с форматом PDU (protocol description unit).
              <br>&nbsp;&nbsp;Второе Намерение, deliveryIntent, срабатывает только после того, как адресат получил ваше сообщение.
              <br>&nbsp;&nbsp;Длина текста в SMS, как правило, ограничена 160 символами, поэтому сообщения, которые выходят за эти рамки, должны быть разбиты на несколько более мелких частей. Класс SmsManager содержит метод divideMessage, который принимает в качестве параметра строку и делит ее на массив с сообщениями, каждое из которых имеет допустимый размер. Затем вы можете использовать метод sendMultipartTextMessage из SmsManager, чтобы отослать полученный массив.</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288579552" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">
              <p style="text-align: center;"><strong style="font-size: 24px;">Аудио и видео</strong></p>&nbsp;&nbsp;За проигрывание мультимедийных файлов в Android отвечает класс MediaPlayer. Вы можете воспроизводить медиаданные, размещенные в ресурсах приложения, локальных файлах, Источниках данных или в сетевом потоке. В каждом случае вы как разработчик абстрагируетесь от форматов файлов и типов мультимедийных данных.
              <br>&nbsp;&nbsp;В объекте MediaPlayer управление аудио- и видеофайлами реализовано в виде машины состояний. Если говорить более простым языком, режимы, через которые проходит эта машина состояний, можно описать так:
              <br>&nbsp;&nbsp;• инициализация Медиапроигрывателя с помощью заданных мультимедийных данных;
              <br>&nbsp;&nbsp;• подготовка объекта MediaPlayer к воспроизведению;
              <br>&nbsp;&nbsp;• запуск воспроизведения;
              <br>&nbsp;&nbsp;• временная или полная остановка во время воспроизведения;
              <br>&nbsp;&nbsp;• завершение воспроизведения.
              <br>&nbsp;&nbsp;Более детальное и исчерпывающее описание машины состояний Медиапроигрывателя вы можете найти на сайте для разработчиков по адресу: http://developer.android.com/reference/android/media/MediaPlayer.html#StateDiagram.
              <br>&nbsp;&nbsp;Чтобы проигрывать мультимедийный ресурс, необходимо создать новый экземпляр класса MediaPlayer, инициализировать его с помощью источника медиаданных и подготовить к воспроизведению.
              <br>&nbsp;&nbsp;Воспроизведение видеоданных немного сложнее, чем аудио. Чтобы отобразить видео, необходимо указать поверхность, на которой оно будет выводиться. Распростанено два способа воспроизведения видеоданных.
              <br>&nbsp;&nbsp;Первый предусматривает использование элемента VideoView и инкапсулирует создание и размещение поверхности для отображения видео, а также его подготовку внутри Медиапроигрывателя.
              <br>&nbsp;&nbsp;Второй позволяет указать собственную поверхность для воспроизведения, управляя исходным экземпляром MediaPlayer напрямую.
              <br>&nbsp;&nbsp;Android предлагает два разных пути для записи аудио и видео внутри приложения. Самый простой способ — использование Намерений для запуска стандартного приложения, управляющего камерой. Это позволяет указать качество видео и место, куда его сохранять. Вся работа по записи видео, взаимодействию с пользователем и отлавливанию ошибок «ложится на плечи» стандартного приложения. Если нужен более тонкий контроль над пользовательским интерфейсом или параметрами записи и вы хотите заменить стандартное приложение, можете воспользоваться классом MediaRecorder.</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288579925" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">
              <p style="text-align: center;"><strong style="font-size: 24px;">Использование камеры и создание снимков</strong><span style="font-size: 24px;"> </span></p>&nbsp;&nbsp;Вместе с ростом популярности цифровых камер (особенно внутри мобильных телефонов), цены на них значительно снизились, а сами камеры стали намного компактнее. Сейчас трудно найти мобильный телефон без камеры, и устройства на базе Android не исключение.
              <br>&nbsp;&nbsp;Самый простой способ сделать снимок с помощью камеры — использовать статическую константу ACTION_IMAGE_CAPTURE из объекта MediaStore для создания Намерения, которое потом нужно передать методу startActivityForResult.
              <br>&nbsp;&nbsp;Данный код запустит Активность для управления камерой, позволяя таким образом пользователям вручную изменять настройки изображения (это освобождает вас от необходимости создавать свое собственное приложение для этих нужд).
              <br>&nbsp;&nbsp;Процесс создания снимков предусматривает два режима.
              <br>&nbsp;&nbsp;• Миниатюра. По умолчанию фотография возвращается в виде объекта Bitmap, содержащего миниатюру. Этот объект находится в параметре data, передаваемом в метод onActivityResult. Чтобы получить миниатюру в виде объекта Bitmap, нужно вызвать метод getParcelableExtra из Намерения, передав ему строковое значение data.
              <br>&nbsp;&nbsp;• Полноценное изображение. Если вы укажете исходящий путь URI с помощью параметра MediaStore.EXTRA_OUTPUT в запущенном Намерении, полноразмерное изображение, снятое камерой, сохранится в заданном месте. В таком случае в метод onActivityResult не будет передана миниатюра, а итоговое Намерение продемонстрирует значение null.
              <br>&nbsp;&nbsp;Чтобы получить прямой доступ к аппаратным возможностям камеры, необходимо добавить полномочие CAMERA в манифест своего приложения.
              <br>&nbsp;&nbsp;Используйте класс Camera, чтобы откорректировать настройки камеры, указать параметры изображения и сделать снимок.
              <br>&nbsp;&nbsp;Сделайте снимок, вызвав метод takePicture из объекта Camera, передав ему в качестве параметров ShutterCallback и две реализации PictureCallback (одну для необработанных изображений, другую для сжатых в формат JPEG). Каждая из этих двух функций обратного вызова получит массив байтов — изображение в соответствующем формате, тогда как ShutterCallback сработает сразу после закрытия затвора камеры.
              <br>&nbsp;&nbsp;Класс ExifInterface предоставляет механизм для чтения и изменения данных EXIF (Exchangeable Image File Format) внутри файла в формате JPEG. Создайте новый экземпляр этого класса, передав в его конструктор полное имя файла.</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288580286" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="248">
      <!-- T220 -->
      <div class="t220">
        <div class="t-container ">
          <div class="t-col t-col_8 t-prefix_2">
            <div class="t220__textwrapper" style="background-color:#f5f6ff;">
              <div style="">
                <div field="text" class="t220__text t-text t-text_md " style="">ExifInterface exif = new ExifInterface(filename); </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288580412" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;Формат EXIF предназначен для хранения широкого спектра метаданных, описывающих фотографии, включая дату и время, свойства камеры (марку и модель), настройки изображения (апертуру и выдержку), а также описание снимка и информацию о местоположении.</div>
          </div>
        </div>
      </div>
    </div>
    <div id="rec288580483" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106">
      <!-- T004 -->
      <div class="t004">
        <div class="t-container ">
          <div class="t-col t-col_10 t-prefix_1">
            <div field="text" class="t-text t-text_md " style="">
              <p style="text-align: center;"><strong style="font-size: 24px; line-height: 20px;">Запись изображений</strong></p>&nbsp;&nbsp;По умолчанию мультимедийные файлы, созданные вашим приложением, недоступны для других программ. Выход из этой ситуации — добавление таких файлов в источник MediaStore, с помощью которого любое приложение может получить к ним доступ. Android предоставляет два способа добавления данных в MediaStore: использование Сервиса MediaScannerConnection, который автоматически распознает и внесет ваш файл, или вручную добавление новой записи в соответствующий Источник данных.
              <br>&nbsp;&nbsp;Если вы записали медиафайл, класс MediaScannerConnection поможет вам легко добавить его в MediaStore, избавляя от необходимости вручную создавать запись в этом Источнике данных. Прежде чем использовать метод scanFile, чтобы начать сканирование файла, необходимо вызвать метод connect и дождаться установления связи с Сервисом MediaScannerConnection. Этот вызов проходит в асинхронном режиме, поэтому вы должны реализовать интерфейс MediaScannerConnectionClient — оповестить приложение, что связь была установлена. Можно использовать этот же класс для уведомлений о завершении сканирования, чтобы знать, когда необходимо разорвать связь с MediaScannerConnection.
              <br>&nbsp;&nbsp;Вместо того чтобы полагаться на MediaScannerConnection, вы сами можете добавить медиафайл в MediaStore, создав новый объект ContentValues и вставив его в соответствующий Источник данных. В качестве метаданных для нового медиафайла нужно указывать название, временную отметку (timestamp) и географическую информацию.
              <br>
              <br>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>


  <!-- Stat -->

</body>

</html>